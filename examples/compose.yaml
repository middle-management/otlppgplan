services:
  # PostgreSQL with auto_explain enabled
  postgres:
    image: postgres:16-alpine
    container_name: postgres-autoexplain
    environment:
      POSTGRES_PASSWORD: postgres
      POSTGRES_DB: testdb
    ports:
      - "5432:5432"
    command:
      - postgres
      - -c
      - shared_preload_libraries=auto_explain
      - -c
      - auto_explain.log_min_duration=0
      - -c
      - auto_explain.log_analyze=on
      - -c
      - auto_explain.log_buffers=on
      - -c
      - auto_explain.log_timing=on
      - -c
      - auto_explain.log_format=json
      - -c
      - auto_explain.log_nested_statements=on
      - -c
      - log_destination=stderr
      - -c
      - logging_collector=off
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5
    configs:
      - source: postgres_init
        target: /docker-entrypoint-initdb.d/init.sql

  # Log forwarder using otel-logger
  log-forwarder:
    image: golang:1.25-alpine
    container_name: log-forwarder
    command: >
      sh -c "apk add --no-cache docker-cli &&
             docker logs -f postgres-autoexplain 2>&1 |
             go run github.com/middle-management/otel-logger@latest"
    environment:
      OTEL_EXPORTER_OTLP_ENDPOINT: http://otel-collector-pgplan:4319
      OTEL_SERVICE_NAME: postgresql
    volumes:
      - /var/run/docker.sock:/var/run/docker.sock:ro
    depends_on:
      postgres:
        condition: service_healthy
      otel-collector-pgplan:
        condition: service_started
    restart: unless-stopped

  # Custom collector with pgplan connector
  otel-collector-pgplan:
    build:
      context: ..
      dockerfile: examples/Dockerfile
    container_name: otel-collector-pgplan
    ports:
      - "4319" # OTLP HTTP receiver
      - "4317" # OTLP gRPC receiver (for trace export)
    command: ["--config=/etc/otel-collector-config.yaml"]
    healthcheck:
      test: ["CMD", "wget", "--spider", "-q", "http://localhost:13133/"]
      interval: 5s
      timeout: 5s
      retries: 5
    configs:
      - source: otel_pgplan_config
        target: /etc/otel-collector-config.yaml

  # Jaeger for viewing traces
  jaeger:
    image: jaegertracing/all-in-one:1.54
    container_name: jaeger
    ports:
      - "16686:16686" # Jaeger UI
      - "14250:14250" # gRPC collector
    environment:
      - COLLECTOR_OTLP_ENABLED=true

configs:
  postgres_init:
    content: |
      -- Initialize test database with sample data
      CREATE TABLE users (
          id SERIAL PRIMARY KEY,
          name VARCHAR(100),
          email VARCHAR(100),
          created_at TIMESTAMP DEFAULT NOW()
      );

      CREATE TABLE orders (
          id SERIAL PRIMARY KEY,
          user_id INTEGER REFERENCES users(id),
          total DECIMAL(10, 2),
          status VARCHAR(20),
          created_at TIMESTAMP DEFAULT NOW()
      );

      -- Insert sample data
      INSERT INTO users (name, email)
      SELECT 'User ' || i, 'user' || i || '@example.com'
      FROM generate_series(1, 1000) i;

      INSERT INTO orders (user_id, total, status)
      SELECT
          (random() * 999 + 1)::int,
          (random() * 1000)::decimal(10,2),
          CASE WHEN random() < 0.3 THEN 'pending'
               WHEN random() < 0.7 THEN 'completed'
               ELSE 'cancelled'
          END
      FROM generate_series(1, 5000);

      -- Create indexes
      CREATE INDEX idx_users_email ON users(email);
      CREATE INDEX idx_orders_user_id ON orders(user_id);
      CREATE INDEX idx_orders_status ON orders(status);
      CREATE INDEX idx_orders_created_at ON orders(created_at);

      ANALYZE users;
      ANALYZE orders;

      -- Create functions for testing nested calls
      -- Level 3: Get order details
      CREATE OR REPLACE FUNCTION get_order_details(p_order_id INTEGER)
      RETURNS TABLE(order_id INTEGER, user_name VARCHAR, total DECIMAL) AS $$func$$
          SELECT o.id, u.name, o.total
          FROM orders o
          JOIN users u ON o.user_id = u.id
          WHERE o.id = p_order_id;
      $$func$$ LANGUAGE sql;

      -- Level 2: Calculate user order statistics
      CREATE OR REPLACE FUNCTION get_user_order_stats(p_user_id INTEGER)
      RETURNS TABLE(total_orders BIGINT, total_spent DECIMAL, avg_order DECIMAL) AS $$func$$
          SELECT
              COUNT(*)::BIGINT,
              SUM(total),
              AVG(total)
          FROM orders
          WHERE user_id = p_user_id
            AND status = 'completed';
      $$func$$ LANGUAGE sql;

      -- Level 1: Process order (calls other functions)
      CREATE OR REPLACE FUNCTION process_order(p_order_id INTEGER)
      RETURNS TABLE(
          order_info TEXT,
          user_stats TEXT
      ) AS $$func$$
      DECLARE
          v_user_id INTEGER;
          v_order_details RECORD;
          v_user_stats RECORD;
      BEGIN
          -- Get order details (triggers auto_explain)
          SELECT * INTO v_order_details
          FROM get_order_details(p_order_id);

          -- Get user ID from the order
          SELECT user_id INTO v_user_id
          FROM orders
          WHERE id = p_order_id;

          -- Get user statistics (triggers auto_explain)
          SELECT * INTO v_user_stats
          FROM get_user_order_stats(v_user_id);

          -- Return formatted results
          RETURN QUERY SELECT
              format('Order %s: %s - $%s',
                     v_order_details.order_id,
                     v_order_details.user_name,
                     v_order_details.total)::TEXT,
              format('User stats: %s orders, $%s total, $%s avg',
                     v_user_stats.total_orders,
                     v_user_stats.total_spent,
                     v_user_stats.avg_order)::TEXT;
      END;
      $$func$$ LANGUAGE plpgsql;

      -- Create a test query script with traceparent
      -- This will be in /tmp/test_function_calls.sql inside the container
      CREATE TEMP TABLE test_queries AS
      SELECT 1 as query_num,
             '/*traceparent=''00-' || md5(random()::text) || md5(random()::text) || '-' ||
              substring(md5(random()::text), 1, 16) || '-01''*/ SELECT * FROM process_order(1);' as query
      UNION ALL
      SELECT 2,
             '/*traceparent=''00-' || md5(random()::text) || md5(random()::text) || '-' ||
              substring(md5(random()::text), 1, 16) || '-01''*/ SELECT * FROM process_order(100);'
      UNION ALL
      SELECT 3,
             '/*traceparent=''00-aabbccdd11223344aabbccdd11223344-1122334455667788-01''*/ SELECT * FROM process_order(500);';

      -- Output instructions
      DO $$block$$
      BEGIN
          RAISE NOTICE '';
          RAISE NOTICE '=================================================================';
          RAISE NOTICE 'Test functions created! To test nested function call tracing:';
          RAISE NOTICE '';
          RAISE NOTICE 'Example 1: With explicit traceparent';
          RAISE NOTICE '  /*traceparent=''00-aabbccdd11223344aabbccdd11223344-1122334455667788-01''*/';
          RAISE NOTICE '  SELECT * FROM process_order(500);';
          RAISE NOTICE '';
          RAISE NOTICE 'Example 2: Simple call (generates random trace ID)';
          RAISE NOTICE '  SELECT * FROM process_order(1);';
          RAISE NOTICE '';
          RAISE NOTICE 'This will trigger multiple auto_explain entries:';
          RAISE NOTICE '  1. Main query calling process_order()';
          RAISE NOTICE '  2. Query inside get_order_details()';
          RAISE NOTICE '  3. Query selecting user_id';
          RAISE NOTICE '  4. Query inside get_user_order_stats()';
          RAISE NOTICE '';
          RAISE NOTICE 'All queries from the same session (PID) will share the trace ID!';
          RAISE NOTICE 'View traces at http://localhost:16686';
          RAISE NOTICE '=================================================================';
          RAISE NOTICE '';
      END $$block$$;

  otel_pgplan_config:
    content: |
      receivers:
        otlp:
          protocols:
            grpc:
              endpoint: 0.0.0.0:4317
            http:
              endpoint: 0.0.0.0:4319

      processors:
        batch:
          timeout: 10s

      connectors:
        # Converts PostgreSQL auto_explain logs to traces
        # Handles both formats:
        # - Auto_explain: {"Query Text": "...", "Plan": {...}}
        # - EXPLAIN JSON: [{"Plan": {...}, "Execution Time": ...}]
        # Also strips PostgreSQL log prefix (timestamp, duration, etc.)
        pgplan:
          source:
            type: body
          conversion:
            service_name: postgresql
            include_plan_json: false
            expand_loops: false
          on_error: log

      exporters:
        debug:
          verbosity: detailed
        otlp/jaeger:
          endpoint: jaeger:4317
          tls:
            insecure: true

      service:
        pipelines:
          logs:
            receivers: [otlp]
            exporters: [pgplan, debug]
          traces:
            receivers: [pgplan]
            processors: [batch]
            exporters: [otlp/jaeger, debug]

networks:
  default:
    name: pgplan-demo
